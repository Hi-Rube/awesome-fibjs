##fibjs 和 nodejs 并发模型上的差异性分析 
  响马：大家好，我是响马。今天我们简单一点，直接切入到正题。今天我给大家讲的是fibjs的逻辑，主要对比分析在解决并发问题的时候 fibjs 跟 nodejs 思考的逻辑有什么不同？

简单介绍一下什么是 fibjs，fibjs 跟 nodejs 是做的事情很相似，都是服务器端 javascript 运行环境，我们的引擎也是一样的，都是用v8做的，但是我们在并发的解决方式上不一样，nodejs 主要是回调的方式，fibjs 是用 fiber 解决的，模块组织上都是 commonjs，fibjs 代码是C++写的，总共是有8万多行，模块有27个，这个今天就简单介绍，不展开了。

我们主要来看 fibjs 和 nodejs 有甚么不一样的地方？这是比较常见的数据库的操作，大家可以看到，这个是  query 所谓一个 sql 命令，有一个回调函数，先判断是不是有错误，如果有错误就抛出来，然后我们判断一下返回数据的一个字段，根据这个值再执行下一个sql，进来再判断一下是不是有错误，最后把结果输出出来，这是我们用nodejs回调的逻辑。我们看看右边的 fibjs 的实现，请求然后判结果然后就没有了。

这里面有不一样的地方，第一个是fibjs里面没有回调的，每个都是直接执行的，就像大家最初上大一写的编程语言一样，另外一个就是错误处理，我们看nodejs里面每一个函数回调入口的时候都要判断这个这一次的回调是不是出错了，因为nodejs本身用的回调，所以完全没有办法利用 javascript 本身的错误处理体系，就必须在每个回调判断是不是出错，因为回调再加上错误处理的复杂性，导致这个代码越来越复杂就很难读下去了。

并且还有一个情况是什么呢？回调是一个很恶心的编程模式，只要在一个模块当中用的回调，所有调用有这个模块的模块全部都要回调，回调是向上传染的。

再看看 fibjs 的写法，是不使用回调的，直截了当。如果出现错误，直接使用 javascript 的错误机制抛出，不需要任何特殊的错误处理。

nodejs为什么使用回调，这个是有原因的，nodejs在最初的时候有一份 ppt，他认为在服务器应用中间用异步比同步更快。这是他举的例子，大家看ngnx的曲线在上面，比 apache 快很多，这个是他使用回调的理论基础。

但是异步不一定是更快的，回调是一个解决办法，他解决的是什么呢？我不知道大家有没有测试过，我在早几年测过，所有的操作同步都是比异步快的。异步更快是假的，同步永远是更快的。ngnx使用异步不是因为异步更快，而是解决连接数量的问题。

这是早些年大家遇到的 c10k 问题，我第一次看到这个问题是2000年，一帮程序员讨论的时候怎么解决，那个时候我写 windows，用 iocp，根本没有这个问题。那个时候，每个新建的连接要有个线程，线程就要有对应的堆栈。一万个连接，每个线程 1M，就是10G，那个时候根本没有这么大的内存，异步处理最终解决了内存占用问题，并不是因为更快。C10k 时有很多的连接占用大量的内存，不够的时候就要写到磁盘上面去，这个就很慢。

同时你的连接连上并不是有很频繁请求，比如 web 服务器，一次点击和下次可能间隔1分钟，也有可能间隔10分钟，这个是不确定的，所以呢其实你的服务器大量的时间是在等待的状态，而不是处理状态，所以说当你有1万个链接大家等着的时候，这个时候其实这个内存占用是很浪费的。因为这些特点现在的所有的服务器应用都是用的异步处理，这样的话可以把堆栈释放出来。

那么再看下面一个特点，因为所有的服务器有效的请求时间都是比较短的，我们孢子社区在自己的应用当中，要求所有的服务器请求50毫秒以内返回，假设慢一点，100毫秒返回，每秒处理1000个请求，就是你一台服务器一天要处理将近1亿的请求，这个对于绝大多数的应用讲是做不到的，即便如此，一千个请求，每个请求是100毫秒，并发的请求是只有100个。一百个相当于什么概念？就是相当于每一个连接占用1M的内存就是100M而已，对现在的操作系统来讲，现在的设备来讲，根本就没有意义，根本不算什么东西，在绝大多数的WEB应用场景当中因为100M的内存释放，你去用异步是完全没有意义的，没有解决任何的问题，所以异步并不是意味着更快，只是解决某一些问题的方式，不是在所有的地方都应该使用异步。

所以 nodejs 对异步的认知是错误的，整个社区为这个错误付出了沉重的代价，这句话比较激烈，经过网友建议，换了一个措词：nodejs对异步的认知是存在问题的，整个社区本来有机会创造更大的辉煌，这个是温和一点的说法。

我们来看一下基于这个认识，两种设计模式的结果是什么样的，这个是简单的是fibjs和nodejs的性能测试，上面蓝色是fibjs的，绿色是nodejs，大家可以看到这两个差距是多大，上面是在4万多，下面是连1万都做不到，这个在同样的设备同样的测试脚本，这个测试脚本在fibjs的社区中可以看到，这个并不是一个特殊设计的测试，是最简单的测试。
平均起来7.25倍，这个是fibjs和nodejs的差异，还有一个前提就是说nodejs已经把CPU跑满了，已经没有任何的余地，而fibjs的CPU没有用满还有很大的余地，客户端跑满了，测试客户端没有能力跑的更快了。

当时这个结果发出去有网友做了测试，他认为fibjs是多线程的，nodejs是一个线程所以会比较慢，他就开始用cluster做测试。我们看看他用了一堆 nodejs 是什么效果，大概只能跑到fibjs的80-90%，这个是他用了一堆nodejs的结果，然后另外一个结果是什么呢，虽然跑到80-90%，但是CPU高了很多，性能差异是很显而易见的。

我们看一下fibjs是怎么实现的？fibjs 有三种主要的线程，一个是javascript，是v8，第二个工作线程池是为了拓展来做的，第三个异步IO线程是为了把所有的异步操作委托出来。

第一个线程是 javascript 线程，对于 fibjs 和 nodejs，每个进程只会开一个 vm，也有开源项目开了多个VM，但是所有vm之间是互相隔离的，其实跟开多个进程没有差别，那个方式我不太建议，会导致整个垃圾回收乱掉。另外一个就是会运行多个fiber，代码在这个当中运行。当前fiber休眠时其他的fiber才会恢复，这个是fiber的运行基础，这个就不展开了。也就是说在我们一个v8的线程当中有N个这样的运行，我们测试在一个设备上面跑了一万多个的fiber是很稳定的。

我们说很多阻塞的操作会把 javascript 线程塞住，怎么样把这个操作给摘出来？当我们去recv的时候，这个javascript引擎不要等着而去做别的事情，这时候就会把socket.recv处理，把这些数据全部打包扔给一个异步IO线程由他处理，丢过去之后这个fiber就会主动把自己挂起来，挂起来之后，javascript的线程会找另外一个排队的 fiber 在哪，把它恢复出来，让他执行，当这个异步IO线程执行完成之后，把返回结果打包，把对应的 fiber 再丢回到队列里面，当 javascript 完成其他 fiber 计算后这个会激活。你在使用的时候看起来，就是当我读这个的时候就卡住了，返回的结果是往下走，你的逻辑看起来跟单线程没有任何的差异，而实际上是所有N个javascript 会一起往前跑的，这个就是异步IO线程的处理方式。

另外一种操作是阻塞的操作，readfile是用阻塞的方式做，这个是等待磁盘操作的过程，如果也放到javascript里面，会导致这个javascript完全塞在这里，读的时候其他的javascript也没有办法执行。这样的操作同样的打包丢出来，会丢在工作线程池里面去，那里有很多的工作线程停在那里等，发现你有一个fs.readfile去做，就会拿过去跑，跑完后把这个返回结果同样的打包回来，这个过程当中这个fiber在读这个readfile时候把 javascript vm 释放出来，结束的时候再恢复运行。

我们刚刚看了，所有的三个线程当中最敏感的或者是最关键的线程是javascript线程，因为javascript只有一个线程，他只有一个线程或者是一个CPU跑，就算跑满了也就是这么多资源，所以最大限度的把javascript的运行时间释放掉，这个是提高整个框架的根本。所以为了让这个事情变的更好，我们做了更多的工作，我们把更多的运算移到工作线程池里面。刚才讲过了，我们会把异步的IO丢到异步线程里面，会把堵塞的IO丢到工作线程池里面，实际上我们做的更多了一些。

第一个操作是同步IO操作，这个刚刚已经说过了，另外一个是计算密集的方法，比如说加密，比如说MD5，比如说做了RSA，RC4，AES，所有的加密解密操作，包括压缩，还有就是图象处理，比如说图象的压缩解压缩，都是在线程池里面运行的。当你做这些需要耗费CPU的操作的时候，javascript 都是被释放出来的，都是可以干别的事情的。

异步io基础上的复杂操作，典型的是协议处理，也是在线程池内运行的。这个说的比较简单，但是做起来是很复杂的，当我去读一个包进来，这个是有一个请求，会丢到工作线程池里面做，如果这个请求包不是完整的，会再到异步IO线程里面读数据，然后再丢到线程池里面做，一直到这个包是完整的解开。整个的处理过程当中不需要javascript参与的，这个也是为什么到最后请求是会比nodejs快很多的原因。

因为我们很多的操作都会丢到工作线程池里面，fibjs还有一个特点，我们有完备的静态文件处理，全部都在这个里面，用fibjs处理静态请求的时候是没有javascript参与的，这个过程是完全对javascript引擎是透明的，我们把更多的工作丢在这样的环节里面。

因为我们把javascript线程宝贵的运算资源完全释放出来了，只有用户的逻辑需要在这个上面运行，所以呢我们在同样的一个100%的运行时间里面，我们可以有更多的事务被处理掉。同时另外一点工作线程池是多线程的模式，可以有N个压缩，同时有N个图象处理在里面跑，或者是整个某个线程在很频繁的处理 http 请求，所有的都不会占用javascript的时间。这个都是很充分利用多核的时间，可以把多个CPU的线程用的淋漓尽致。

昨天老许说我今天批判异步，其实我是不批判异步的，大家看到fibjs在底层的里面大量用异步的，我们的异步IO线程用异步，异步io所关联的操作都是异步的，javascript内部其实有几十个状态机的处理，每个状态机都是每一层的处理，这些都是异步的，fibjs整个底层全部是异步的，只是我们在javascript这一块封装起来了，让大家看起来是一个同步的东西，让我们的业务逻辑写的更干净更舒服一些。同时呢因为我们大量的在多线程当中运行异步，所以我们会服务器的性能很充分的使用掉。

这些是fibjs在孢子社区的实践。这个是基于fiber的数据并行读取，我们在做后端的时候遇到一种情况读N个数据源的请求，然后再服务器端合并起来返回到客户端。一般我们的做法就是用循环读很多的请求，在fibjs里面我们有这个优势，你可以使用 coroutine.parrel 来并行执行。比如说请求一个数据库，我们用数组设定一组数据源，他把这些并行的发出去，一起返回的时候也是这样的数组，结束之后把这个请求合并起来返回客户端，当我们请求10个数据源的时候请求速度就可以提高10倍。

另外是后端的异步化，我们很多的后端操作是你发了一个帖子，我们会把你发的这个帖子通知关注的人，而发帖人不需要知道这些，并不需要所有人通知完了之后告诉法帖人发完了，这个是两步完成的，第一个是这个帖子你发了一个跟帖，只要是能被看到，我们就可以把这个结果返回给用户，告诉他你的发贴已经成功，同时我们在成功之前我用了一个另外的fiber这个在后端执行，会一点一点把该通知谁做什么样的操作完成，这个发贴人不知道，他觉得很快结束，但是后面可能要执行更长的时间。很多的操作都可以异步化，通过这个提高用户体验。

下面的两个应用是基于fibjs的sandbox进行的处理。我们使用 sandbox 把这个服务器模块APP化，来做数据隔离。另外我们现在孢子社区服务器代码是热升级的，nodejs里面改一个代码升级都要把服务器重启，这个对用户体验不好，虽然很快的重启但是很多的请求用户没有结束的，中间会丢，有一些事务也会中断。我们孢子社区是在这个里面用fibjs sandbox的对象把服务器做热升级。

sandbox是什么东西呢？是每个sandbox就是一个模块管理器，每个砂箱是完全是独立的。我在sandbox代码模块拎出来，绑定到websever，老的还在执行，新的就已经被加载更换了。新的请求已经会全部的导到新的sandbox里面，当老的sandbox请求执行完了之后，对老sandbox的引用没有了，下次fibjs做垃圾回收的时候会把老sandbox的模块全部摘除，这个对用户是完全透明的，用户的长请包括长请求，没有任何的请求会丢掉。这样热升级的过程，你用 nginx，lvs，用什么都好，切换很难做到这一点的。